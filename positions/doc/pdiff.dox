
 /*! \page page_pdiff Time Derivatives of Positions

This library defines an \ref linearvelocities_interface "interface" for a velocity of a point to enable different representations of a velocity (3D-vector, homogeneous velocity, etc.) and different \ref linearvelocities_implementations "implementations" (based on Eigen, Bullet, etc.). 
The section \ref linearvelocities_interface "Interface" describes the functionalities, whereas the section \ref linearvelocities_implementations "Implementation" shows some examples.

\tableofcontents

\section linearvelocities_interface Interface
The class kinder::linearvelocities::LinearVelocityBase serves as an interface for a velocity of a point. All types of representations of a velocity, such as 3D-vector and homogeneous coordinate, are derived from this base class.

\subsection linearvelocities_zero Zero Velocity
The default constructor always initializes all velocities equal to zero.

All velocities can be set to zero by the function \ref kinder::linearvelocities::LinearVelocityBase::setZero() "setZero()".

\subsection linearvelocities_addition_and_subtraction Addition and Subtraction
Addition and subtraction of linear velocities are provided by the kinder::linearvelocities::LinearVelocityBase::operator+ and kinder::linearvelocities::LinearVelocityBase::operator-, respectively.



\subsection linearvelocities_interfaces_representations Representations of a Linear Velocity
The following representations are currently provided by the library:

\subsubsection linearvelocities_interfaces_velocity3 3-dimensional Linear Velocity
The class kinder::linearvelocities::LinearVelocity3Base defines an interface for a 3D-vector representation of a linear velocity in 3D-Space.
The linear velocity of point P expressed in frame A can be stated as:

\f$\boxed{_A\mathbf{v}_{P} = \begin{bmatrix} v_x \\ v_y \\ v_z \end{bmatrix}}\f$

The three components, x, y and z, are stored and can be accessed by
   
 - \ref kinder::linearvelocities::LinearVelocity3Base::x() "x()"
 - \ref kinder::linearvelocities::LinearVelocity3Base::y() "y()"
 - \ref kinder::linearvelocities::LinearVelocity3Base::z() "z()"


\section linearvelocities_implementations Implementations
Each implementation lies in its own namespace, such that the implementation can be altered later very easily via namespace alias.
For example: 
\code{.cpp}
namespace vel = kinder::linearvelocities::eigen_implementation; // select implementation based on Eigen
vel::LinearVelocity3D velocity();		     // create 3D-Velocity
\endcode
If the implementation needs to be changed, only one line of code has to be altered:
\code{.cpp}
namespace vel = kinder::linearvelocities::bullet_implementation; // select implementation based on bullet	
\endcode
\subsection linearvelocities_eigen Eigen
The library comes along with an implementation based on the <a href="http://eigen.tuxfamily.org">C++ Eigen library</a>.

All types can be included by
\code{.cpp}
#include <kinder/linearvelocities/LinearVelocityEigen.hpp>
\endcode
and lie within the namespace kinder::linearvelocities::eigen_implementation.

\subsubsection linearvelocities_implementation_linearvelocity3 3D Linear Velocity
The class \ref kinder::linearvelocities::eigen_implementation::Velocity3 "Velocity3" stores the three coordinates of the velocity in 3D-space in Eigen::Matrix<PrimType, 3, 1>.

The following four typedefs are provided for convenience:
 - \ref kinder::linearvelocities::eigen_implementation::LinearVelocity3D "LinearVelocity3D" for primitive type double
 - \ref kinder::linearvelocities::eigen_implementation::LinearVelocity3F "LinearVelocity3F" for primitive type float

A velocity can be created as follows:
\code{.cpp}
double x = 1.0;
double y = 2.0;
double z = 3.0;
vel::LinearVelocity3D velocity1();		     		// creates a 3D-Velocity with all coordinates equal to zero
vel::LinearVelocity3D velocity2(x, y, z);	     		// initializes the three coordinates
vel::LinearVelocity3D velocity3(Eigen::Vector3d(x, y, z)); 	// creates a velocity from an Eigen vector
\endcode

The coordinates can be obtained as follows:
\code{.cpp}
x = velocity1.x();
y = velocity1.y();
z = velocity1.z();
Eigen::Vector3d vector = velocity1.toImplementation();	// [x;y;z]
\endcode

Operations with linearvelocities:
\code{.cpp}
  vel::LinearVelocity3D velocity4 = velocity1 + velocity2;	// addition
  vel::LinearVelocity3D velocity3 -= velocity1;		// subtraction
  std::cout << "Velocity 3 is: " << velocity3;		// print velocity
\endcode


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>



*/