 /*! \page page_rdiff Time Derivatives of Rotations

This library defines an \ref rdiff_interface "interface" for an angular velocity of a rigid body to enable different representations of an angular velocity (3D-vector, derivatives of Euler angles, derivative of quaternion, etc.) and different \ref rdiff_implementations "implementations" (based on Eigen, Bullet, etc.). 
The section \ref rdiff_interface "Interface" describes the functionalities, whereas the section \ref rdiff_implementations "Implementation" shows some examples.

\tableofcontents

\section rdiff_interface Interface
The class kinder::rdiff::AngularVelocityBase serves as an interface for an angular velocity of a rigid body. All types of representations of an angular velocity, such as 3D-vector and derivatives of Euler angles, are derived from this base class.

\subsection rdiff_zero Zero Velocity
The default constructor always initializes all velocities equal to zero.

All velocities can be set to zero by the function \ref kinder::rdiff::AngularVelocityBase::setZero() "setZero()".

\subsection rdiff_addition_and_subtraction Addition and Subtraction
Addition and subtraction of angular velocities are provided by the kinder::rdiff::AngularVelocityBase::operator+ and kinder::rdiff::AngularVelocityBase::operator-, respectively.



\subsection rdiff_interfaces_representations Representations of an Angular Velocity
The following representations are currently provided by the library:

\subsubsection rdiff_interfaces_velocity3 3-dimensional Angular Velocity
The class kinder::rdiff::AngularVelocity3Base defines an interface for a 3D-vector representation of an angular velocity in 3D-Space.
The angular velocity expressed in frame A can be stated as:

\f$\boxed{_K\mathbf{\omega}_{IK} = \begin{bmatrix} \omega_x \\ \omega_y \\ \omega_z \end{bmatrix}}\f$

The three components, x, y and z, are stored and can be accessed by
   
 - \ref kinder::rdiff::AngularVelocity3Base::x() "x()"
 - \ref kinder::rdiff::AngularVelocity3Base::y() "y()"
 - \ref kinder::rdiff::AngularVelocity3Base::z() "z()"


\section rdiff_implementations Implementations
Each implementation lies in its own namespace, such that the implementation can be altered later very easily via namespace alias.
For example: 
\code{.cpp}
namespace vel = kinder::rdiff::eigen_implementation; // select implementation based on Eigen
vel::AngularVelocity3D velocity();		     // create 3D-Velocity
\endcode
If the implementation needs to be changed, only one line of code has to be altered:
\code{.cpp}
namespace vel = kinder::rdiff::bullet_implementation; // select implementation based on bullet	
\endcode
\subsection rdiff_eigen Eigen
The library comes along with an implementation based on the <a href="http://eigen.tuxfamily.org">C++ Eigen library</a>.

All types can be included by
\code{.cpp}
#include <kinder/rdiff/AngularVelocityEigen.hpp>
\endcode
and lie within the namespace kinder::rdiff::eigen_implementation.

\subsubsection rdiff_implementation_angularvelocity3 3D Angular Velocity
The class \ref kinder::rdiff::eigen_implementation::Velocity3 "Velocity3" stores the three coordinates of the velocity in 3D-space in Eigen::Matrix<PrimType, 3, 1>.

The following four typedefs are provided for convenience:
 - \ref kinder::rdiff::eigen_implementation::AngularVelocity3D "AngularVelocity3D" for primitive type double
 - \ref kinder::rdiff::eigen_implementation::AngularVelocity3F "AngularVelocity3F" for primitive type float

A velocity can be created as follows:
\code{.cpp}
double x = 1.0;
double y = 2.0;
double z = 3.0;
vel::AngularVelocity3D velocity1();		     		// creates a 3D-Velocity with all coordinates equal to zero
vel::AngularVelocity3D velocity2(x, y, z);	     		// initializes the three coordinates
vel::AngularVelocity3D velocity3(Eigen::Vector3d(x, y, z)); 	// creates a velocity from an Eigen vector
\endcode

The coordinates can be obtained as follows:
\code{.cpp}
x = velocity1.x();
y = velocity1.y();
z = velocity1.z();
Eigen::Vector3d vector = velocity1.toImplementation();	// [x;y;z]
\endcode

Operations with angular velocities:
\code{.cpp}
  vel::AngularVelocity3D velocity4 = velocity1 + velocity2;	// addition
  vel::AngularVelocity3D velocity3 -= velocity1;		// subtraction
  std::cout << "Velocity 3 is: " << velocity3;		// print velocity
\endcode


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>



*/