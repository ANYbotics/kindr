/**
 * \defgroup rotations Rotations
 *  \see \ref page_rotations "Chapter Rotations" 
 */
 
 //-----------------------------------------------------------

/*! \page page_rotations Rotations
This library defines an \ref rotations_interfaces "interface" for a rotation between two rigid bodies to enable different representations of a rotation and different \ref rotations_implementations "implementations". The section \ref rotations_interfaces "Interface" describes the functionalities, whereas the section \ref rotations_implementations "Implementation" shows some examples.

\tableofcontents

\section rotations_interfaces Interface
\subsection rotations_interfaces_rotation Rotation
The class kinder::rotations::RotationBase serves as an interface for a rotation between two rigid bodies. All types of representations of a rotation, such as quaternion, angle-axis, and Euler angles, are derived from this base class.
\subsubsection rotations_interfaces_rotation_ap Active vs. Passive
A rotation can be either active (alibi) or passive (alias).
The class is therefore templated by the enumeration kinder::rotations::RotationUsage which indicates the usage type of a rotation:
- RotationUsage::ACTIVE:  maps the coordinates of the basis vectors of frame A expressed in A into the coordinates of the basis vectors of B expressed in A 
- RotationUsage::PASSIVE: maps the coordinates of the basis vectors of frame A expressed in A into the coordinates of the basis vectors of A expressed in B 

The usage type of a rotation can be identified by the typedef \ref kinder::rotations::RotationBase::Usage "RotationBase::Usage".

An active rotation can be obtained from a passive rotation by the function \ref kinder::rotations::RotationBase::getPassive() "getPassive()", and a passive from an active by \ref kinder::rotations::RotationBase::getActive() "getActive()".

This has the advantage that rotations are type-safe and other users can immediately recognize whether a rotation is used as an active or passive transformation.


\subsubsection rotations_interfaces_rotation_identity Identity Rotation
The default constructor of a rotation always creates an identity rotation.

Any rotation can be set equal to the identity rotation by the function \ref kinder::rotations::RotationBase::setIdentity() "setIdentity()".

\subsubsection rotations_interfaces_rotation_unique Unique Rotation
A rotation can be represented in different ways. The quaternion 
\f$Q = q_0 + q_1 i + q_2 j + q_3 k\f$ and the quaternion \f$Q = -q_0 - q_1 i - q_2 j - q_3 k\f$, for instance, represent the same rotation. However, sometimes a unique representation is desired, e.g. to compare two rotations.

A unique representation is obtained by
- \ref kinder::rotations::RotationBase::getUnique() "getUnique()": gets a copy of the presentation, which is unique, and
- \ref kinder::rotations::RotationBase::setUnique() "setUnique()": sets the representation to the unique representation.

\subsubsection rotations_interfaces_rotation_inverse Inverse of a Rotation
The inverse of a rotation is provided by two methods:
 - \ref kinder::rotations::RotationBase::invert() "invert()" returns and stores the inverse
 - \ref kinder::rotations::RotationBase::inverted() "inverted()" returns only the inverse

\subsubsection rotations_interfaces_rotation_composition Composition of a Rotation
A rotation can be composed of other rotations.
The multiplication operator enables the composition for passive rotations as follows:
\code{.cpp}
C_DA = C_DC*C_CB*C_BA;
\endcode

\subsubsection rotations_interfaces_rotation_rotate Rotation of a Vector or a Matrix
To rotate a vector or a matrix columnwise, the following methods are provided:
- \ref kinder::rotations::RotationBase::rotate() "rotate()": rotates a vector or a matrix columnwise
- \ref kinder::rotations::RotationBase::inverseRotate() "inverseRotate()": reverse rotates a vector or a matrix columnwise

\subsubsection rotations_interfaces_conversion Conversion between Rotations
The constructor and the assignment operator allow to convert between different representations of a rotation:
\code{.cpp}
AngleAxisPD angleAxis;
RotationQuaternionPD quaternion(angleAxis);
angleAxis = quaternion;
\endcode

\subsection rotations_interfaces_representations Representations of a Rotation
The following representations are currently provided by the library:

\subsubsection rotations_interfaces_angleaxis Angle-Axis
The class kinder::rotations::AngleAxisBase defines an interface for an angle-axis representation of a rotation:

\f$\boxed{(\theta, \mathbf{n}), \quad \lVert \mathbf{n} \rVert = 1,}\f$

where \f$\theta\f$ is the rotation angle and \f$\mathbf{n}\f$ is the rotation axis with unit length.
\subsubsection rotations_interfaces_quaternion Rotation Quaternion
The class kinder::rotations::RotationQuaternionBase defines the interface for a Hamiltonian unit quaternion representation of a rotation:

\f$\boxed{\begin{aligned}P &= p_0 + p_1 i + p_2 j + p_3 k \in \mathbb{H}, \quad p_i \in \mathbb{R} \\
i^2 &= j^2=k^2 = ijk = -1, \quad \lVert P \rVert= \sqrt{p_0^2 + p_1^2 + p_2^2 + p_3^2} = 1 \\
\end{aligned}}\f$

\subsubsection rotations_interfaces_rotationmatrix Rotation Matrix
The class kinder::rotations::RotationMatrixBase defines the interface for a 3x3 rotation matrix representation of a rotation:

\f$\boxed{R = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\  r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix} \in SO(3)}\f$

\subsubsection rotations_interfaces_eulerangles Euler Angles
The class kinder::rotations::EulerAnglesBase defines the interface for a tuple of three angles to represent a rotation.

\subsubsection rotations_interfaces_eulerangles_zyx Euler Angles ZYX
The class kinder::rotations::EulerAnglesZyxBase defines the interface for the Z-Y-X convention:

\f$\boxed{(\psi, \theta, \phi ),}\f$

where \f$\psi\f$ is the yaw angle, \f$\theta\f$ is the pitch angle, and \f$\phi\f$ is the roll angle.
The consecutive rotations are shown in the following picture:
\image html EulerAnglesZyx.png

\subsubsection rotations_interfaces_eulerangles_xyz Euler Angles XYZ
The class kinder::rotations::EulerAnglesXyzBase defines the interface for the X-Y-Z convention:

\f$\boxed{(\alpha, \beta, \gamma ),}\f$

where \f$\gamma\f$ is the yaw angle, \f$\beta\f$ is the pitch angle, and \f$\alpha\f$ is the roll angle.
The consecutive rotations are shown in the following picture:
\image html EulerAnglesXyz.png

\section rotations_implementations Implementations
Each implementation lies in its own namespace, such that the implementation can be altered later very easily via namespace alias.
For example: 
\code{.cpp}
namespace rot = kinder::rotations::eigen_implementation; // select implementation based on Eigen
rot::RotationQuaternionAD rquat();		     // create an active rotation quaternion
\endcode
If the implementation needs to be changed, only one line of code has to be changed:
\code{.cpp}
namespace rot = kinder::rotations::bullet_implementation; // select implementation based on bullet	
\endcode
\subsection rotations_eigen Eigen
The library comes along with an implementation based on the <a href="http://eigen.tuxfamily.org">C++ Eigen library</a>.

All types can be included by
\code{.cpp}
#include <rm/rotations/RotationEigen.hpp>
\endcode
and lie within the namespace kinder::rotations::eigen_implementation.

\subsubsection rotations_implementation_angleaxis Angle-Axis
The class \ref kinder::rotations::eigen_implementation::AngleAxis "AngleAxis" stores the angle and rotation axis in Eigen::AngleAxis.

The following four typedefs are provided for convenience:
 - \ref kinder::rotations::eigen_implementation::AngleAxisAD "AngleAxisAD" for active rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::AngleAxisAF "AngleAxisAF" for active rotation and float primary type
 - \ref kinder::rotations::eigen_implementation::AngleAxisPD "AngleAxisPD" for passive rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::AngleAxisPF "AngleAxisPF" for passive rotation and float primary type
 
 \paragraph rotations_implementation_angleaxis_create Create an Angle-Axis
 \code{.cpp}
 double angle = 0.2;
 double n_1 = 1.0;
 double n_2 = 0.0;
 double n_3 = 0.0;
 Eigen::Vector3d axis(n_1, n_2, n_3);
 AngleAxisPD angleAxis1; // identity rotation: angle = 0.0 axis = (1.0, 0.0, 0.0)
 AngleAxisPD angleAxis2(angle, axis);
 AngleAxisPD angleAxis3(angle, n_1, n_2, n_3);
 AngleAxisPD angleAxis4(angle, 1.0, 1.0, 1.0); // will create an error in debug mode
 \endcode
 
 \paragraph rotations_implementation_angleaxis_use Use an Angle-Axis
  \code{.cpp}
    double angle = angleAxis.angle();									// get rotation angle 
    Eigen::Vector3d axis = angleAxis.axis();								// get rotation axis
    Eigen::AngleAxisd angleAxisEigen = angleAxis.toImplementation();					// get Eigen angle-axis
    Eigen::Vector3d vector_rotated = angleAxis.rotate(Eigen::Vector3d(1.0,2.0,3.0));			// rotate a vector
    Eigen::Vector3d vector_invrotated = angleAxis.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));		// reverse rotate a vector
    angleAxis.setUnique(); 										// Modifies the angle such that it is in [0,PI)
    std::cout << "Angle-Axis: " << angleAxis << std::endl:						// output angle-axis
    if (angleAxis == AngleAxisPD(M_PI/2.0, 1.0, 0.0, 0.0)) 						   	// compare angle-axis
	std::cout << "Rotation is about x-axis with angle M_PI/2.0\n"; 
  \endcode
 
 
\subsubsection rotations_implementation_quaternion Rotation Quaternion
The class \ref kinder::rotations::eigen_implementation::RotationQuaternion "RotationQuaternion" stores the coefficients according to the kinder::quaterions::UnitQuaternion.
See also \ref page_quaternions "Chapter Quternions" for more information.

The following four typedefs are provided for convenience:
 - \ref kinder::rotations::eigen_implementation::RotationQuaternionAD "RotationQuaternionAD" for active rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::RotationQuaternionAF "RotationQuaternionAF" for active rotation and float primary type
 - \ref kinder::rotations::eigen_implementation::RotationQuaternionPD "RotationQuaternionPD" for passive rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::RotationQuaternionPF "RotationQuaternionPF" for passive rotation and float primary type

 
\paragraph rotations_implementation_quaternion_create Create a Quaternion
\code{.cpp}
double p_0 = 1.0;
double p_1 = 0.0;
double p_2 = 0.0;
double p_3 = 0.0;
RotationQuaternionPD rquat1; // identity rotation: (1.0, 0.0, 0.0, 0.0)
RotationQuaternionPD rquat2(p_0, p_1, p_2, p_3);
RotationQuaternionPD rquat3(Eigen::Quaterniond(p_0, p_1, p_2, p_3));
RotationQuaternionPD rquat4(1.0, 1.0, 1.0, 1.0); // will create an error in debug mode
\endcode

\paragraph rotations_implementation_quaternion_use Use a Quaternion
\code{.cpp}
  double p_0 = rquat.w();									
  double p_1 = rquat.x();
  double p_2 = rquat.y();
  double p_3 = rquat.z();
  Eigen::Quaterniond quatEigen = rquat.toImplementation();						// get Eigen quaternion
  UnitQuaternionD uquat = rquat.toUnitQuaternion();							// get unit quaternion
  Eigen::Vector3d vector_rotated = rquat.rotate(Eigen::Vector3d(1.0,2.0,3.0));				// rotate a vector
  Eigen::Vector3d vector_invrotated = rquat.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));		// reverse rotate a vector
  rquat.setUnique(); 											// Modifies the quaternion such that p_0 >= 0
  std::cout << "Quaternion: " << rquat << std::endl:							// output quaternion
  if (rquat == RotationQuaternionPD()) 						 			// compare 
      std::cout << "Rotation is identity\n"; 
\endcode
 
\subsubsection rotations_implementation_rotationmatrix Rotation Matrix
The class \ref kinder::rotations::eigen_implementation::RotationMatrix "RotationMatrix" stores the coefficients in Eigen::Matrix.

The following four typedefs are provided for convenience:
 - \ref kinder::rotations::eigen_implementation::RotationMatrixAD "RotationMatrixAD" for active rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::RotationMatrixAF "RotationMatrixAF" for active rotation and float primary type
 - \ref kinder::rotations::eigen_implementation::RotationMatrixPD "RotationMatrixPD" for passive rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::RotationMatrixPF "RotationMatrixPF" for passive rotation and float primary type
 
 \paragraph rotations_implementation_rotationmatrix_create Create a Rotation Matrix
 \code{.cpp}
   RotationMatrixPD rmat1; 			// identity rotation: diag(1.0, 1.0, 1.0)
   RotationMatrixPD rmat2(r11, r12, r13,	// rotation matrix from coefficients
			  r21 ,r22, r23,
			  r31, r32, r33);
   Eigen::Matrix3d mat;				// rotation matrix from Eigen matrix
   mat << r11, r12, r13,
	  r21 ,r22, r23,
	  r31, r32, r33;
   RotationMatrixPD rmat3(mat);   
 \endcode
 
 \paragraph rotations_implementation_rotationmatrix_use Use a Rotation Matrix
 \code{.cpp}
  Eigen::Matrix3d mat = rmat.matrix();									// get Eigen matrix	
  Eigen::Vector3d vector_rotated = rmat.rotate(Eigen::Vector3d(1.0,2.0,3.0));				// rotate a vector
  Eigen::Vector3d vector_invrotated = rmat.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));			// reverse rotate a vector
  double determinant = rmat.determinant();								// get the determinant of the matrix
  std::cout << "Rotation matrix: " << rmat << std::endl:						// output rotation matrix
  if (rmat == RotationMatrixPD()) 						 			// compare 
      std::cout << "Rotation is identity\n"; 
\endcode

\subsubsection rotations_implementation_eulerangles_zyx Euler Angles ZYX
The class \ref kinder::rotations::eigen_implementation::EulerAnglesZyx "EulerAnglesZyx" stores the coefficients in Eigen::Vector3.

The following four typedefs are provided for convenience:
 - \ref kinder::rotations::eigen_implementation::EulerAnglesZyxAD "EulerAnglesZyxAD" for active rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::EulerAnglesZyxAF "EulerAnglesZyxAF" for active rotation and float primary type
 - \ref kinder::rotations::eigen_implementation::EulerAnglesZyxPD "EulerAnglesZyxPD" for passive rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::EulerAnglesZyxPF "EulerAnglesZyxPF" for passive rotation and float primary type
 
\paragraph rotations_implementation_eulerangleszyx_create Create Euler Angles ZYX
\code{.cpp}
  double yaw = 0.3;					// angle around z-axis
  double pitch = 0.2;					// angle around new y-axis
  double roll = 0.1; 					// angle around new x-axis
  EulerAnglesZyxPD angles1;				// identity rotation (0, 0, 0)
  EulerAnglesZyxPD angles2(yaw, pitch, roll);		
  EulerAnglesZyxPD angles3(Eigen::Vector3d(roll, pitch, yaw));		// attention: different order!
\endcode
 
\paragraph rotations_implementation_eulerangleszyx_use Use  Euler Angles ZYX
\code{.cpp}
  double roll = angles.roll();
  double pitch = angles.pitch();
  double yaw = angles.yaw();
  roll = angles.x();
  pitch = angles.y();
  yaw = angles.z();
  Eigen::Vector3d angleVector = angles.toImplementation();	// [roll; pitch; yaw]
  angles.setUnique()						// Modifies the angles, such that yaw in [-pi,pi), pitch in [-pi/2,pi/2), roll in [-pi,pi)
\endcode
 
\subsubsection rotations_implementation_eulerangles_xyz Euler Angles XYZ
The class \ref kinder::rotations::eigen_implementation::EulerAnglesXyz "EulerAnglesXyz" stores the coefficients in Eigen::Vector3.

The following four typedefs are provided for convenience:
 - \ref kinder::rotations::eigen_implementation::EulerAnglesXyzAD "EulerAnglesXyzAD" for active rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::EulerAnglesXyzAF "EulerAnglesXyzAF" for active rotation and float primary type
 - \ref kinder::rotations::eigen_implementation::EulerAnglesXyzPD "EulerAnglesXyzPD" for passive rotation and double primary type
 - \ref kinder::rotations::eigen_implementation::EulerAnglesXyzPF "EulerAnglesXyzPF" for passive rotation and float primary type
 
\paragraph rotations_implementation_euleranglesxyz_create Create Euler Angles XYZ
 \code{.cpp}
  double roll = 0.1; 					// angle around x-axis
  double pitch = 0.2;					// angle around new y-axis
  double yaw = 0.3;					// angle around new z-axis
  EulerAnglesXyzPD angles1;				// identity rotation (0, 0, 0)
  EulerAnglesXyzPD angles2(roll, pitch, yaw);		
  EulerAnglesXyzPD angles3(Eigen::Vector3d(roll, pitch, yaw));
\endcode

\paragraph rotations_implementation_euleranglesxyz_use Use Euler Angles XYZ
 \code{.cpp}
  double roll = angles.roll();
  double pitch = angles.pitch();
  double yaw = angles.yaw();
  roll = angles.x();
  pitch = angles.y();
  yaw = angles.z();
  Eigen::Vector3d angleVector = angles.toImplementation();	// [roll; pitch; yaw]
  angles.setUnique()						// Modifies the angles, such that roll in [-pi,pi), pitch in [-pi/2,pi/2), yaw in [-pi,pi)
\endcode
*/