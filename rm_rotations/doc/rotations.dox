/**
 * \defgroup rotations Rotations
 *  \see \ref page_rotations "Chapter Rotations" 
 */
 
 //-----------------------------------------------------------

/*! \page page_rotations Rotations
This library defines an \ref rotations_interfaces "interface" for a rotation between two rigid bodies to enable different representations of a rotation and different \ref rotations_implementations "implementations". The section \ref rotations_interfaces "Interface" describes the functionalities, whereas the section \ref rotations_implementations "Implementation" shows some examples.

\tableofcontents

\section rotations_interfaces Interface
\subsection rotations_interfaces_rotation Rotation
The class rm::rotations::RotationBase serves as an interface for a rotation between two rigid bodies. All types of representations of a rotation, such as quaternion, angle-axis, and Euler angles, are derived from this base class.
\subsubsection rotations_interfaces_rotation_ap Active vs. Passive
A rotation can be either active (alibi) or passive (alias).
The class is therefore templated by the enumeration rm::rotations::RotationUsage which indicates the usage type of a rotation:
- RotationUsage::ACTIVE (alias)
- RotationUsage::PASSIVE (alibi)

The usage type of a rotation can be identified by the typedef \ref rm::rotations::RotationBase::Usage "RotationBase::Usage".

An active rotation can be obtained from a passive rotation by the function \ref rm::rotations::RotationBase::getPassive() "getPassive()", and a passive from an active by \ref rm::rotations::RotationBase::getActive() "getActive()".

This has the advantage that rotations are type-safe and other users can immediately recognize whether a rotation is used as an active or passive transformation.


\subsubsection rotations_interfaces_rotation_identity Identity Rotation
The default constructor of a rotation always creates an identity rotation.

Any rotation can be set equal to the identity rotation by the function \ref rm::rotations::RotationBase::setIdentity() "setIdentity()".

\subsubsection rotations_interfaces_rotation_unique Unique Rotation
A rotation can be represented in different ways. The quaternion 
\f$Q = q_0 + q_1 i + q_2 j + q_3 k\f$ and the quaternion \f$Q = -q_0 - q_1 i - q_2 j - q_3 k\f$, for instance, represent the same rotation. However, sometimes a unique representation is desired, e.g. to compare two rotations.

A unique representation is obtained by
- \ref rm::rotations::RotationBase::getUnique() "getUnique()": gets a copy of the presentation, which is unique, and
- \ref rm::rotations::RotationBase::setUnique() "setUnique()": sets the representation to the unique representation.

\subsubsection rotations_interfaces_rotation_inverse Inverse of a Rotation
The inverse of a rotation is provided by two methods:
 - \ref rm::rotations::RotationBase::invert() "invert()" returns and stores the inverse
 - \ref rm::rotations::RotationBase::inverted() "inverted()" returns only the inverse

\subsubsection rotations_interfaces_rotation_composition Composition of a Rotation
A rotation can be composed of other rotations.
The multiplication operator enables the composition for passive rotations as follows:
\code{.cpp}
C_DA = C_DC*C_CB*C_BA;
\endcode

\subsubsection rotations_interfaces_conversion Conversion between Rotations
The constructor and the assignment operator allow to convert between different representations of a rotation:
\code{.cpp}
AngleAxisPD angleAxis;
RotationQuaternionPD quaternion(angleAxis);
angleAxis = quaternion;
\endcode

\subsection rotations_interfaces_representations Representations of a Rotation
The following representations are currently provided by the library:

\subsubsection rotations_interfaces_angleaxis Angle-Axis
The class rm::rotations::AngleAxisBase defines an interface for an angle-axis representation of a rotation:

\f$\boxed{(\theta, \mathbf{n}), \quad \lVert \mathbf{n} \rVert = 1,}\f$

where \f$\theta\f$ is the rotation angle and \f$\mathbf{n}\f$ is the rotation axis with unit length.
\subsubsection rotations_interfaces_quaternion Rotation Quaternion
The class rm::rotations::RotationQuaternionBase defines the interface for a Hamiltonian unit quaternion representation of a rotation:

\f$\boxed{\begin{aligned}P &= p_0 + p_1 i + p_2 j + p_3 k \in \mathbb{H}, \quad p_i \in \mathbb{R} \\
i^2 &= j^2=k^2 = ijk = -1, \quad \lVert P \rVert= \sqrt{p_0^2 + p_1^2 + p_2^2 + p_3^2} = 1 \\
\end{aligned}}\f$

\subsubsection rotations_interfaces_rotationmatrix Rotation Matrix
The class rm::rotations::RotationMatrixBase defines the interface for a 3x3 rotation matrix representation of a rotation:

\f$\boxed{R = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\  r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix} \in SO(3)}\f$

\subsubsection rotations_interfaces_eulerangles Euler Angles
The class rm::rotations::EulerAnglesBase defines the interface for a tuple of three angles to represent a rotation.

\subsubsection rotations_interfaces_eulerangles_zyx Euler Angles ZYX
The class rm::rotations::EulerAnglesZyxBase defines the interface for the Z-Y-X convention:

\f$\boxed{(\psi, \theta, \phi ),}\f$

where \f$\psi\f$ is the yaw angle, \f$\theta\f$ is the pitch angle, and \f$\phi\f$ is the roll angle.
The consecutive rotations are shown in the following picture:
\image html EulerAnglesZyx.png

\subsubsection rotations_interfaces_eulerangles_xyz Euler Angles XYZ
The class rm::rotations::EulerAnglesXyzBase defines the interface for the X-Y-Z convention:

\f$\boxed{(\alpha, \beta, \gamma ),}\f$

where \f$\gamma\f$ is the yaw angle, \f$\beta\f$ is the pitch angle, and \f$\alpha\f$ is the roll angle.
The consecutive rotations are shown in the following picture:
\image html EulerAnglesXyz.png

\section rotations_implementations Implementations
Each implementation lies in its own namespace, such that the implementation can be altered later very easily via namespace alias.
For example: 
\code{.cpp}
namespace rot = rm::rotations::eigen_implementation; // select implementation based on Eigen
rot::RotationQuaternionAD rquat();		     // create an active rotation quaternion
\endcode
If the implementation needs to be changed, only one line of code has to be changed:
\code{.cpp}
namespace rot = rm::rotations::bullet_implementation; // select implementation based on bullet	
\endcode
\subsection rotations_eigen Eigen

*/